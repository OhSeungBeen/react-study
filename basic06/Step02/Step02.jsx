// React Redux

// Redux 3 가지 규칙
// 단일 스토어
// 하나의 애플리케이션 안에는 하나의 스토어가 존재, 여러 스토어를 만들 수 있지만 상태 관리가 복잡해지므로 사용 하지 않는다.
// 읽기 전용 상태
// 리덕스 상태는 읽기 전용이다. 기존 리액트에서 setState를 사용하여 state업데이트할 때 객체나 배열을 업데이트 하는 과정에서
// 불변성을 지켜주었다. 리덕스도 마찬가지이다. 기존 객체는 건드리지 않고 새로운 객체를 생성해 주어야 한다.
// 내부적으로 데이터가 변경되는 것을 감지하기 위해 얕은 비교 검사를 하기 때문이다
// 리듀서 함수
// 변화를 일으키는 리듀서는 순수 함수여야 한다. 이전 상태와 액션 객체를 파라미터로 받는다. 파라미터 외의 값에 의존하면 안된다.
// 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환한다. 현재시간 가져오기, 랜덤값 만들기, 네트워크 요청등
// 이러한 작업은 리듀서 함수 밖에서 처리한다. 액션 또는 미들웨어

// 프레젠테이셔널 컴포넌트, 컨테이너 컴포넌트 분리 패턴
// 프레젠테이셔널 컴포넌트는 상태 관리가 이루어지지 않고, 그저 props를 받아와서 화면에 UI를 보여 주기만 하는 컴포넌트 이다.
// 컨테이너 컴포넌트는 리덕스와 연동되어 있는 컴포넌트로, 리덕스로 부터 상태를 받아 오기도 하고 리덕스 스토어에 액션을 디스
// 패치한다.
// 이 패턴을 사용하면 코드의 재사용성을 높일 수 있다.

// 리덕스 관련 코드 구조
// 액션 타입, 액션 생성 함수, 리듀서 코드 이코드들을 각각 다른 파일에 작성하는 방법과 기능별로 묶어서 파일 하나에 작성하는 방법이 있다.
// 1.가장 일반적인구조로 actions, constants, reducers라는 세 개의 디렉터리를 만들고 그안에 기능별로 파일을 만드는 방식이다.
// 새로운 액션을 만들 때마다 세 종류의 파일을 모두 수정해야 하는 불편함이 있다.
// 2.액션타입, 액션생성 함수, 리듀서 함수를 기능별로 파일하나에 작성하는 방법이 있다. Ducks 패턴이라고 불린다.

import React from 'react';
import CounterContainer from './containers/CounterContainer';
import Todo from './components/Todos';
import TodoContainer from './containers/TodoContainer';

const Step02 = (state) => {
  return (
    <div>
      <CounterContainer />
      <hr />
      <TodoContainer />
    </div>
  );
};

export default Step02;
